# 一个简单的c语言编译器 03  虚拟机设计

因为传统的汇编语言例如x86、risc-v指令集比较复杂因此本项目中我们自己手动实现一个自己的虚拟机，其本质目的是设计出自己的指令集用来也就是一套汇编语言，在编译器最终实现目标代码的生成，这将作为我们的最后的输出形式。

## 计算机内部工作原理

在计算机组成原理中，计算机事实上有非常重要的五大部件，分别为控制器、运算器、存储器、输入设备、输出设备。但是在这里我们只需要考虑到计算机的更核心三个基本部件，cpu、寄存器和内存。当我们的计算机在工作时，我们所编写的代码（其本质是二进制代码）是保存在内存中，cpu会从内存中加载一条一条指令，而程序的状态则是保存在寄存器中。

### 内存

内存在计算机中是非常重要的，内存可以存储数据当然这个数据是多种多样的。在计算机飞速发展的今天传统的物理内存已经满足不了大多数计算机的需求，因此现在的操作系统大多数采用虚拟内存的方式来管理内存，操作系统会将我们使用的虚拟地址进行映射到实际的物理存储上。

当一个程序存储到内存中时，实际上会分成很多的段：

1.代码段，用来存放代码（或者是指令）。（text）

2.数据段，用于存放已经初始化的数据，因为c语言是静态编译语言。（data）

3.未初始化的数据段，用来存放未初始化的数据段，这样分开存储的目的是可以方便管理。毕竟我们也不知道这些变量的初值是多少。（bss）

4.栈用于处理函数调用的相关的数据，如调用帧或者是函数的局部变量等等。（stack）

5.堆，为程序动态分配内存（heap）

对于本项目，我们只需要考虑代码段，数据段，以及栈即可。在用户程序运行时计算机实际上会给程序分配内存，理论上需要一个堆来进行维护但是在实现上这个堆比较复杂，本项目不考虑这种的实现方法，只是引入一个指令`MEST`,使得我们设计的编译器其实是解释器了可以直接使用内存了。

### 寄存器

对于寄存器这里我们设计了四个寄存器：

1.`PC`程序计数寄存器，程序计数器中存放的是下一条将要执行的指令的内存地址。

2.`SP`指针寄存器，SP指针永远指向当前的栈顶，因为在计算机中栈是由高地址向低地址发展的因此，在入栈的时候SP的值其实是在减少的。

3.`BP`基址指针寄存器，基址指针也是指向栈内的某个位置。

4.`AX`通用寄存器，在虚拟机中，通用寄存器我们用来存放指令执行后的结果。

### 指令集

指令集作为虚拟机模块的核心内容，这部分我们参考了`x86`汇编语言的指令集，但是本项目实现的指令集相对更简单。

#### `MOV`

`mov`指令是汇编语言中最基本的指令，其主要目的是将数据放进寄存器或者内存地址，类似于c语言中的赋值语句，在`x86`中`mov`指令有两个参数，分别为源地址和目的地址，`MOV dest,source`，这条指令表示将`source`的内容放进`dest`中，对于汇编语言来说这些可以是数据、寄存器、也可以是一个内存地址。

对于本项目来说，我们只有一个寄存器，因此我们对于`MOV`指令的实现进行简化和拆分。

1.`IMM<num>` 将`<num>`放进寄存器ax中

2.`LC`将对应的地址中的字符载入寄存器ax中，ax要求存入地址

3.`LI`将对应的地址中的整数载入寄存器ax中，ax要求存入地址

4.`SC`将ax中的数据作为字符存入地址，要求栈顶存放地址

5.`SI`将ax中的数据作为整数存入地址，要求栈顶存放地址

这五条指令实现简单的`mov`功能，但是对于`x86`中的`mov`其实还有功能没有实现，这里只要符合我们项目的需求即可。

#### `PUSH`

在本项目中`push`指令的目的是将`ax`的值放入栈中。

#### `JMP`

`JMP<addr>`为跳转指令，无条件将现在的`PC`寄存器设为指定的`address`。但因为`PC`存放的是下一条指令的地址，因此此时存放的是`JMP`指令中的`address`。

#### `JZ/JNZ`

这两条指令实现的是条件转移，即判断`ax`中的数据为0或不为0情况下的跳转。

子函数调用

这个部分算是指令内容中比较复杂的部分具体涉及到四个指令`CALL`，`ENT`，`ADJ`和`LEV`。

`CALL<addr>`与`ENT`指令，`CALL`指令的目标是跳转到地址为`<addr>`的子函数，`RET`则用于从子函数返回。

如果使用`JMP`实现会出现一个显著的问题，如果我们想从子函数中返回那么程序需要跳转到之前的地方继续运行，这就需要你将之前程序运行的地址存储起来。并且子函数返回时，也需要恢复这个信息，所以在实际实现中我们将`PC`保存在栈中。`RET`指令后面我们会使用`LEV`来代替。

在调用函数中，不仅仅我们要考虑函数的地址问题，更重要的我们也要考虑函数传递的参数和返回的结果。本项目中如果子函数有返回结果，那么我们将返回结果存入`ax`中，它可以是一个值也可以是地址。参数的传递我们规定是顺序传参，但是c语言的调用标准是逆序传参。

为了更好地理解，可以给出一个c语言的例子来理解。

```c++
nt callee(int, int, int);

int caller(void)
{
	int i, ret;

	ret = callee(1, 2, 3);
	ret += 5;
	return ret;
}
```

这段程序会生成如下的`x86`汇编代码：

```
caller:	
		; make new call frame	
		push    ebp	
		mov     ebp, esp        
		sub     1, esp       ; save stack for variable: i	
		; push call arguments	
		push    3	
		push    2	
		push    1	
		; call subroutine 'callee'	
		call    callee	
		; remove arguments from frame	
		add     esp, 12	
		; use subroutine result	
		add     eax, 5	
		; restore old call frame        
		mov     esp, ebp	
		pop     ebp	
		; return	
		ret
```

这段汇编语言里面许多的指令我们的虚拟机指令其实都不支持，因此我们想要实现这段汇编语言，我们所使用的方法就是增加指令集。

#### `ENT`

`ENT<size>`指的是`enter`，用于实现 ‘make new call frame’的功能，其本质思想就是存储当前的栈指针，同时在栈上保存一定的空间，用来存放子函数的一些局部变量。

#### `ADJ`

`ADJ<size>`用于实现‘remove arguments from frame’，将调用子函数时所压入栈的数据清除，但是因为我们所设计的`ADD`指令功能有限。

#### `LEV`

因为我们的指令集中没有实现`POP`指令，因此设计`LEV`指令并且这条指令中也包含了`RET`指令因此也不需要在设计`RET`指令了。

#### `LEA`

```
sub_function(arg1, arg2, arg3);
|    ....       | high address
+---------------+
| arg: 1        |    new_bp + 4
+---------------+
| arg: 2        |    new_bp + 3
+---------------+
| arg: 3        |    new_bp + 2
+---------------+
|return address |    new_bp + 1
+---------------+
| old BP        | <- new BP
+---------------+
| local var 1   |    new_bp - 1
+---------------+
| local var 2   |    new_bp - 2
+---------------+
|    ....       |  low address
```

观察这段汇编语言代码想要获取到`new_bp + 4`但是我们的`ADD`指令无法对`ax`以外的寄存器操作，因此我们设计了新的指令`LEA<offset>`

#### 运算符指令

我们为c语言支持的二元运算符都进行了支持，即都有两个，第一个参数我们放在栈顶，第二个参数我们放在ax中，这个要注意因为例如-，/这些运算与参数顺序有关联。计算后会将栈顶的参数进行退栈，将结果放在寄存器ax中，所以在计算之后参与计算的这两个参数事实上我们都无法再获取了。

#### 内置函数

同时我们想实现一些函数比如printf，但是本身这类函数的实现就非常复杂，我们设计的c语言编译器，一大前提就是这个编译器我们要自举。因此我们我们实现一些内置函数指令。需要用到这些函数：`exit，open，close，read，printf，malloc，memset，memcmp`

同时我们的指令设计到了最后了，我们最后只需要补充一个错误判读即可。

```c++
else 
{    
    printf("unknown instruction:%d\n", op);    
    return -1;
}
```



