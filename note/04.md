# 一个简单的c语言编译器 04  词法分析器

## 词法分析器是什么

词法分析器是用于对源代码字符串进行预处理，从而减轻语法分析器的复杂程度。

词法分析器是以源码字符串作为输入，输出为标记流，即一连串的标记也就是我们常说的`token`，每个`token`通常包括`(token，token_value)`，表示标记和标记的值。通过词法分析器的预处理，语法分析器的复杂度会大大降低，这点在后面的语法分析器我们就能体会。

从小的方面来看其实词法分析器也是一个小型的编译器，编译器本质上输入的是标记流，输出一段相对应的汇编代码，而词法分析器对应的输入是源代码字符串，输出的是标记流。如果我们直接对源代码进行语法分析相对应的就会很困难，但是如果我们可以先将源代码转化为简化的标记流那么，对于语法分析的部分来讲就会简单一些。

## 实现

词法分析的工作普遍比较枯燥且易错，因此目前已经有许多自动生成工具来生成词法分析器。例如：`lex，flex`。

在实现词法分析器之前，还有一个问题要说明一下，在本词法分析器中我们并不会一次性将所有的源码都生成为标记流。因为字符串转化为标记流所对应的上下文是有关联的。其次有些标记流是没有意义的因此我们也无需保留。

我们实现的框架就是每次想要生成下一个标记就调用`next()`函数。

在学习c语言时我们会经常发现一些标记是包括多个字符的例如==，<<等这些标记如果不进行处理后续会非常麻烦，因此我们所支持的标记符都会压缩为单个字符，当然有一些字符自己就构成的标记例如波浪号`~`，右方括号`]`类似这些字符我们就不会进行预处理，因为这些字符是单字符，并且也不涉及优先关系。

这里我们要额外介绍 `lookahead` 的概念，即提前看多个字符。上述代码中我们看到，除了跳过注释，我们还可能返回除号 `/(Div)` 标记。

提前看字符的原理是：有一个或多个标记是以同样的字符开头的（如本小节中的注释与除号），因此只凭当前的字符我们并无法确定具体应该解释成哪一个标记，所以只能再向前查看字符，如本例需向前查看一个字符，若是 `/` 则说明是注释，反之则是除号。

我们之前说过，词法分析器本质上也是编译器，其实提前看字符的概念也存在于编译器，只是这时就是提前看k个“标记”而不是“字符”了。平时听到的 `LL(k)` 中的 `k` 就是需要向前看的标记的个数了。

另外，我们用词法分析器将源码转换成标记流，能减小语法分析复杂度，原因之一就是减少了语法分析器需要“向前看”的字符个数。

### 关键字与内置函数

虽然上面写完了词法分析器，但还有一个问题需要考虑，那就是“关键字”，例如 `if`, `while`, `return` 等。它们不能被作为普通的标识符，因为有特殊的含义。

一般有两种处理方法：

1. 词法分析器中直接解析这些关键字。
2. 在语法分析前将关键字提前加入符号表。

这里我们就采用第二种方法，将它们加入符号表，并提前为它们赋予必要的信息（还记得前面说的标识符 `Token` 字段吗？）。这样当源代码中出现关键字时，它们会被解析成标识符，但由于符号表中已经有了相关的信息，我们就能知道它们是特殊的关键字。

